<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Pose Task Game</title>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5.1675469404/pose.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <style>
    html, body { margin: 0; padding: 0; height: 100%; }
    body { 
      background: #111; font-family: sans-serif; display: flex;
      flex-direction: column; align-items: center; justify-content: flex-start;
    }
    h1, h2 { color: white; text-align: center; }
    #container { position: relative; width: 640px; height: 480px; margin-top: 20px; }
    video, canvas { position: absolute; left: 0; top: 0; width: 100%; height: 100%; }
    #reset-btn, .level-btn {
      margin: 10px; padding: 10px 20px; font-size: 16px;
      cursor: pointer; border-radius: 8px; border: none;
    }
    .hidden { display: none; }
    #level-buttons { margin-top: 20px; }
  </style>
</head>
<body>
  <h1 id="task-title">Pose Task Game</h1>
  <h2 id="status" style="color:yellow;">Choose a level to begin...</h2>

  <div id="level-buttons">
    <button class="level-btn" onclick="startLevel(1)">Start Level 1</button>
    <button class="level-btn" onclick="startLevel(2)">Start Level 2</button>
  </div>

  <button id="reset-btn" class="hidden">Run Again</button>

  <div id="container">
    <video id="video" autoplay playsinline></video>
    <canvas id="output"></canvas>
  </div>

  <script>
    const video = document.getElementById("video");
    const canvas = document.getElementById("output");
    const ctx = canvas.getContext("2d");
    video.width = canvas.width = 640;
    video.height = canvas.height = 480;

    const statusElement = document.getElementById("status");
    const titleElement = document.getElementById("task-title");
    const resetButton = document.getElementById("reset-btn");

    let task = null;
    let taskComplete = false;

    function speakText(text) {
      window.speechSynthesis.cancel();
      const utterance = new SpeechSynthesisUtterance(text);
      utterance.rate = 0.9;
      window.speechSynthesis.speak(utterance);
    }

    // --- LEVEL 1 CHECK ---
    function checkHiding(landmarks) {
      const nose = landmarks[0];
      const leftHip = landmarks[23];
      const rightHip = landmarks[24];
      if (nose.visibility > 0.5 && leftHip.visibility > 0.5 && rightHip.visibility > 0.5) {
        const avgHipY = (leftHip.y + rightHip.y) / 2;
        return nose.y > avgHipY;
      }
      return false;
    }

    // --- LEVEL 2 CHECK ---
    function checkLyingDown(landmarks) {
      const leftShoulder = landmarks[11];
      const rightShoulder = landmarks[12];
      const leftHip = landmarks[23];
      if (leftShoulder.visibility > 0.5 && rightShoulder.visibility > 0.5 && leftHip.visibility > 0.5) {
        const shoulderWidth = Math.abs(leftShoulder.x - rightShoulder.x);
        const torsoHeight = Math.abs(leftShoulder.y - leftHip.y);
        return shoulderWidth > torsoHeight * 1.5;
      }
      return false;
    }

    // --- Reset Function ---
    function resetGame() {
      taskComplete = false;
      resetButton.classList.add("hidden");
      statusElement.textContent = "Waiting for you to complete the task...";
      statusElement.style.color = "yellow";
      titleElement.textContent = task.description;
      window.speechSynthesis.cancel();
    }
    resetButton.addEventListener('click', resetGame);

    // --- Start Level ---
    function startLevel(level) {
      if (level === 1) {
        task = { description: "Task: Hide under a table (get your head below your hips!)", check: checkHiding };
      } else if (level === 2) {
        task = { description: "Task: Lie down horizontally!", check: checkLyingDown };
      }
      resetGame();
    }

    // --- Mediapipe Pose Setup ---
    const pose = new Pose({
      locateFile: file => `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5.1675469404/${file}`
    });
    pose.setOptions({
      modelComplexity: 1,
      smoothLandmarks: true,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });

    pose.onResults(results => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

      if (results.poseLandmarks) {
        drawConnectors(ctx, results.poseLandmarks, POSE_CONNECTIONS, { color: 'lime', lineWidth: 3 });
        drawLandmarks(ctx, results.poseLandmarks, { color: 'red', radius: 4 });

        if (task && !taskComplete && task.check(results.poseLandmarks)) {
          taskComplete = true;
          titleElement.textContent = "ðŸŽ‰ Congratulations! ðŸŽ‰";
          statusElement.textContent = "You have completed the task!";
          statusElement.style.color = "lightgreen";
          speakText("Congratulations, you have completed the task.");
          resetButton.classList.remove("hidden");
        }
      }
    });

    const camera = new Camera(video, {
      onFrame: async () => await pose.send({ image: video }),
      width: 640,
      height: 480
    });
    camera.start();

    // --- Drawing Helpers ---
    function drawConnectors(ctx,l,c,s={}) {
      const {color:t="lime",lineWidth:o=2}=s;
      ctx.strokeStyle=t; ctx.lineWidth=o;
      c.forEach(([s,c])=>{
        const n=l[s],i=l[c];
        n&&i&&n.visibility>.5&&i.visibility>.5&&(
          ctx.beginPath(),
          ctx.moveTo(n.x*canvas.width,n.y*canvas.height),
          ctx.lineTo(i.x*canvas.width,i.y*canvas.height),
          ctx.stroke()
        )
      })
    }
    function drawLandmarks(ctx,l,s={}) {
      const {color:t="red",radius:o=4}=s;
      ctx.fillStyle=t;
      l.forEach(s=>{
        s.visibility>.5&&(ctx.beginPath(),
        ctx.arc(s.x*canvas.width,s.y*canvas.height,o,0,2*Math.PI),
        ctx.fill())
      })
    }
    const POSE_CONNECTIONS=[[11,13],[13,15],[12,14],[14,16],[11,12],[23,24],[23,25],[25,27],[24,26],[26,28],[27,29],[29,31],[28,30],[30,32]];
  </script>
</body>
</html>
